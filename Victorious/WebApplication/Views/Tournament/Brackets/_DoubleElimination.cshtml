@model Tournament.Structure.IBracket

@{
    int topRounds = Model.NumberOfRounds;
    int botRounds = Model.NumberOfLowerRounds;
    int maxRounds = Math.Max(topRounds, botRounds);
    int totalRounds = maxRounds + 1;

    int topRoundIndex = 1;
    int botRoundIndex = 1;

    int grandFinals = totalRounds;
    int finalRound = grandFinals - 1;
    int semiFinalRound = finalRound - 1;
    int quarterFinalRound = semiFinalRound - 1;

    bool isPowerOfTwo = (Model.Players.Count & (Model.Players.Count - 1)) == 0;
}

<li class="list-table-header">
    <ul class="border" data-columns="@totalRounds">
        @for (int i = 1; i <= totalRounds; i++)
        {
            String displayTitle = "Round " + i;
            if (i == grandFinals)
            {
                displayTitle = "Grand Finals";
            }
            else if (i == finalRound)
            {
                displayTitle = "Finals";
            }

            <li class="column">@displayTitle</li>
        }
    </ul>
</li>
<li class="list-table-body">
    <ul data-columns="@totalRounds">
        @{
            // Upper Bracket
            for (int i = 1; i < totalRounds; i++)
            {
                // Verify if we can put things in this round
                List<Tournament.Structure.IMatch> matches = Model.GetRound(topRoundIndex);

                <li class="round" data-round="@topRoundIndex">

                    @if (isPowerOfTwo && (i > 2 && i % 2 != 0))
                    {

                    }
                    else
                    {
                        foreach (var match in matches)
                        {
                            var challenger = match.Players[(int)Tournament.Structure.PlayerSlot.Challenger] != null ? match.Players[(int)Tournament.Structure.PlayerSlot.Challenger] : new Tournament.Structure.User();
                            var defender = match.Players[(int)Tournament.Structure.PlayerSlot.Defender] != null ? match.Players[(int)Tournament.Structure.PlayerSlot.Defender] : new Tournament.Structure.User();

                            // maybe a slight bug in previous match number's indexs? 
                            if (challenger.Id == -1)
                            {
                                if (match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Challenger] != -1)
                                {
                                    challenger.Name = "Winner of " + match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Challenger];
                                }
                            }
                            if (defender.Id == -1)
                            {
                                if (match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Defender] != -1)
                                {
                                    defender.Name = "Winner of " + match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Defender];
                                }
                            }

                            ViewBag.Challenger = challenger;
                            ViewBag.Defender = defender;

                            Html.RenderPartial("Brackets/_Match", match, new ViewDataDictionary(ViewData));
                        }
                        topRoundIndex++;
                    }
                </li>
            }
        }
    </ul>

    <ul data-columns="@totalRounds">
        @{
            // Lower Bracket
            for (int i = 1; i < totalRounds; i++)
            {
                // Verify if we can put things in this round
                List<Tournament.Structure.IMatch> matches = Model.GetLowerRound(botRoundIndex);

                <li class="round" data-round="@botRoundIndex">
                    @foreach (var match in matches)
                    {
                        var challenger = match.Players[(int)Tournament.Structure.PlayerSlot.Challenger] != null ? match.Players[(int)Tournament.Structure.PlayerSlot.Challenger] : new Tournament.Structure.User();
                        var defender = match.Players[(int)Tournament.Structure.PlayerSlot.Defender] != null ? match.Players[(int)Tournament.Structure.PlayerSlot.Defender] : new Tournament.Structure.User();

                        // maybe a slight bug in previous match number's indexs? 
                        if (challenger.Id == -1)
                        {
                            if (match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Challenger] != -1)
                            {
                                challenger.Name = "Winner of " + match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Challenger];
                            }
                        }
                        if (defender.Id == -1)
                        {
                            if (match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Defender] != -1)
                            {
                                defender.Name = "Winner of " + match.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Defender];
                            }
                        }

                        ViewBag.Challenger = challenger;
                        ViewBag.Defender = defender;

                        Html.RenderPartial("Brackets/_Match", match, new ViewDataDictionary(ViewData));
                    }
                </li>

                botRoundIndex++;
            }
        }
    </ul>
    <ul data-columns="@totalRounds">
        @{
            for (int roundNum = 1; roundNum <= totalRounds && Model.GrandFinal != null; roundNum++)
            {
                <li class="round">
                    @if (roundNum == totalRounds)
                    {
                        var challenger = Model.GrandFinal.Players[(int)Tournament.Structure.PlayerSlot.Challenger] != null ? Model.GrandFinal.Players[(int)Tournament.Structure.PlayerSlot.Challenger] : new Tournament.Structure.User();
                        var defender = Model.GrandFinal.Players[(int)Tournament.Structure.PlayerSlot.Defender] != null ? Model.GrandFinal.Players[(int)Tournament.Structure.PlayerSlot.Defender] : new Tournament.Structure.User();

                        // maybe a slight bug in previous match number's indexs? 
                        if (challenger.Id == -1)
                        {
                            if (Model.GrandFinal.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Challenger] != -1)
                            {
                                challenger.Name = "Winner of " + Model.GrandFinal.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Challenger];
                            }
                        }
                        if (defender.Id == -1)
                        {
                            if (Model.GrandFinal.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Defender] != -1)
                            {
                                defender.Name = "Winner of " + Model.GrandFinal.PreviousMatchNumbers[(int)Tournament.Structure.PlayerSlot.Defender];
                            }
                        }

                        ViewBag.Challenger = challenger;
                        ViewBag.Defender = defender;
                        ViewBag.ClassName = "grandFinal";

                        Html.RenderPartial("Brackets/_Match", Model.GrandFinal, new ViewDataDictionary(ViewData));
                    }
                </li>
            }
        }
    </ul>
</li>